{
  "hash": "2ad647e3c4812ba608a384f99be12116",
  "result": {
    "markdown": "---\ntitle: \"Googledrive SQLite\"\nformat: html\neditor_options: \n  chunk_output_type: console\n---\n\n\n## Uso de GoogleDrive como Base de datos\n\nEste documento ejemplifica el uso de Google Drive como base de datos. Además, es un esnayo de uso de *Observable JS* como base para aplicaciones interactivas. Puede aprenderse un poco más sobre esto en <https://quarto.org/docs/interactive/ojs/>.\n\nHe recurrido a una pequeña herramienta que reune toda la información referente al contenido del Google Drive a partir de una carpeta inicial. Esa información la organiza en una pequeña base de datos que deposita en un archivo **SQLite**. La estructura de esta base de datos se ilustra a continuación:\n\n![](images/Pronaces-A.png)\n\nA esta estructura de *metadatos* de **Google Drive** le hemos agregado espacio para reunir la tabla de conceptos y el vínculo entre documentos y conceptos. Lo hacemos mediante dos tablas adicionales. De esta manera, la estructura de la base de datos quedaría como se ilustra en seguida.\n\n![](images/conceptos.png)\n\n## Listas de contenido en GD\n\nElige una tabla para desplegar los elementos de información recabados:\n\n\n\n\n```{ojs}\n//| echo: false\n//| panel: input\nviewof tabla = Inputs.radio(\n  [\n    \"drive_folders\",\n    \"drive_files\",\n    \"drive_users\",\n    \"conceptos\",\n    \"tema_doc\",\n  ], \n  { label: \"Tabla:\", value: \"drive_folders\"}\n)\n\n```\n\n\nInformación recabada por *Google Drive* en la tabla seleccionada arriba:\n\n\n```{ojs}\n//| echo: false\ndb = FileAttachment(\"pronaces.db\").sqlite()\n\ndb.describe(tabla)\n\n```\n\n\nVeamos ahora el contenido de una carpeta seleccionada. Para referencia y ejemplo consideremos la carpeta *Libro Semillas*. Prácticamente todas las búsquedas programáticas que hagamos recurrirán al **id** único, asignado a la carpeta de interés. ¿Cuál es el **id** de esta carpeta?. Usemos los recursos que acabamos de describir para averiguarlo.\n\n\n```{ojs}\n\nsql_id = \"SELECT id, name FROM drive_folders WHERE  name LIKE '%Libro semillas%'\"\n\nresultado_1 = db.query(sql_id)\n\nInputs.table(resultado_1, {  columns: [\"name\", \"id\"]})\n```\n\n\n\\\n\\\n\nAsí que el **id** en Google Drive del documento que nos interesa es: **1uOrhAvjddeDxgyfIyDaoyKNivp63vUvO**\n\n\\\n\\\n\nAhora podemos averiguar que documentos o carpetas están aquí. Esto depende de dos tablas diferentes: *drive_files* y *drive_folders*.\n\n\n```{ojs}\n//| echo: false\n\nsql_base = \"SELECT name, mimeType FROM drive_files WHERE _parent = '1uOrhAvjddeDxgyfIyDaoyKNivp63vUvO'\"\n\nviewof consulta = Inputs.textarea({label: \"Consulta\", \n                            placeholder: \"Ingresa una consulta SQL\", \n                            value: sql_base, \n                            submit: true})\n\n\nfld_interes = db.query(consulta)\n\nInputs.table(fld_interes, {  columns: [\n    \"name\", \"mimeType\"]})\n```\n\n\n## Conceptos\n\n\n```{ojs}\n//| echo: false\n\nsunburst = {\n  const root = partition(flareData);\n\n  root.each(d => d.current = d);\n\n  const svg = d3.create(\"svg\")\n      .attr(\"viewBox\", [0, 0, width, width])\n      .style(\"font\", \"15px sans-serif\");\n\n  const g = svg.append(\"g\")\n      .attr(\"transform\", `translate(${width / 2},${width / 2})`);\n\n  const path = g.append(\"g\")\n    .selectAll(\"path\")\n    .data(root.descendants().slice(1))\n    .join(\"path\")\n      .attr(\"fill\", d => { while (d.depth > 1) d = d.parent; return color(d.data.name); })\n      .attr(\"fill-opacity\", d => arcVisible(d.current) ? (d.children ? 0.6 : 0.4) : 0)\n      .attr(\"d\", d => arc(d.current));\n\n  path.filter(d => d.children)\n      .style(\"cursor\", \"pointer\")\n      .on(\"click\", clicked);\n\n  path.append(\"title\")\n      .text(d => `${d.ancestors().map(d => d.data.name).reverse().join(\"/\")}\\n${format(d.value)}`);\n\n  const label = g.append(\"g\")\n      .attr(\"pointer-events\", \"none\")\n      .attr(\"text-anchor\", \"middle\")\n      .style(\"user-select\", \"none\")\n    .selectAll(\"text\")\n    .data(root.descendants().slice(1))\n    .join(\"text\")\n      .attr(\"dy\", \"0.35em\")\n      .attr(\"fill-opacity\", d => +labelVisible(d.current))\n      .attr(\"transform\", d => labelTransform(d.current))\n      .text(d => d.data.name);\n\n  const parent = g.append(\"circle\")\n      .datum(root)\n      .attr(\"r\", radius)\n      .attr(\"fill\", \"none\")\n      .attr(\"pointer-events\", \"all\")\n      .on(\"click\", clicked);\n\n  function clicked(event, p) {\n    parent.datum(p.parent || root);\n\n    root.each(d => d.target = {\n      x0: Math.max(0, Math.min(1, (d.x0 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,\n      x1: Math.max(0, Math.min(1, (d.x1 - p.x0) / (p.x1 - p.x0))) * 2 * Math.PI,\n      y0: Math.max(0, d.y0 - p.depth),\n      y1: Math.max(0, d.y1 - p.depth)\n    });\n\n    const t = g.transition().duration(750);\n\n    // Transition the data on all arcs, even the ones that aren’t visible,\n    // so that if this transition is interrupted, entering arcs will start\n    // the next transition from the desired position.\n    path.transition(t)\n        .tween(\"data\", d => {\n          const i = d3.interpolate(d.current, d.target);\n          return t => d.current = i(t);\n        })\n      .filter(function(d) {\n        return +this.getAttribute(\"fill-opacity\") || arcVisible(d.target);\n      })\n        .attr(\"fill-opacity\", d => arcVisible(d.target) ? (d.children ? 0.6 : 0.4) : 0)\n        .attrTween(\"d\", d => () => arc(d.current));\n\n    label.filter(function(d) {\n        return +this.getAttribute(\"fill-opacity\") || labelVisible(d.target);\n      }).transition(t)\n        .attr(\"fill-opacity\", d => +labelVisible(d.target))\n        .attrTween(\"transform\", d => () => labelTransform(d.current));\n  }\n  \n  function arcVisible(d) {\n    return d.y1 <= 3 && d.y0 >= 1 && d.x1 > d.x0;\n  }\n\n  function labelVisible(d) {\n    return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03;\n  }\n\n  function labelTransform(d) {\n    const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;\n    const y = (d.y0 + d.y1) / 2 * radius;\n    return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;\n  }\n\n  return svg.node();\n}\n```\n\n```{ojs}\n//| echo: false\n\nflareData = FileAttachment(\"flare-2.json\").json()\n\npartition = flareData => {\n  const root = d3.hierarchy(flareData)\n      .sum(d => d.value)\n      .sort((a, b) => b.value - a.value);\n  return d3.partition()\n      .size([2 * Math.PI, root.height + 1])\n    (root);\n}\n\ncolor = d3.scaleOrdinal(\n  d3.quantize(d3.interpolateRainbow, flareData.children.length + 1)\n)\n\nformat = d3.format(\",d\")\n\nwidth = 932\n\nradius = width / 6\n\narc = d3.arc()\n    .startAngle(d => d.x0)\n    .endAngle(d => d.x1)\n    .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))\n    .padRadius(radius * 1.5)\n    .innerRadius(d => d.y0 * radius)\n    .outerRadius(d => Math.max(d.y0 * radius, d.y1 * radius - 1))\n```\n\n\n## Mapas\n\n\n```{ojs}\n//| echo: false\n\nL = {\n  const L = await require(\"leaflet/dist/leaflet.js\");\n  if (!L._style) {\n    const href = await require.resolve(\"leaflet/dist/leaflet.css\");\n    document.head.appendChild(L._style = html`<link href=${href} rel=stylesheet>`);\n  }\n\n  return L;\n};\n\n```\n\n\n\n:::::: {.panel-fill}\n\n```{ojs}\n//| echo: false\n\n\ncontainer = {\n\n  let x = d3.create(\"div\")\n  \n  x.attr(\"style\", `width:100%;height:${window.outerHeight * 0.65}px`);\n\n  return x.node();\n\n}\n\n```\n\n```{ojs}\n//| echo: false\n\n\nsouthwest = {\n  \n  let map = L.map(container);\n  \n  // add basemap layers\n  const stamen = 'Map tiles by <a href=\"http://stamen.com\">Stamen Design</a>, <a href=\"http://creativecommons.org/licenses/by/3.0\">CC BY 3.0</a> &mdash; Map data &copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors';\n  \n  const esri = 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';\n  \n  const Stamen_Terrain = L.tileLayer(\n  'https://stamen-tiles-{s}.a.ssl.fastly.net/terrain/{z}/{x}/{y}{r}.{ext}', \n  {\n  \tattribution: stamen,\n  \tsubdomains: 'abcd',\n  \tminZoom: 0,\n  \tmaxZoom: 18,\n  \text: 'png'\n  });\n  \n  const Stamen_TonerLite = L.tileLayer(\n  'https://stamen-tiles-{s}.a.ssl.fastly.net/toner-lite/{z}/{x}/{y}{r}.{ext}', \n  {\n    attribution: stamen,\n  \tsubdomains: 'abcd',\n  \tminZoom: 0,\n  \tmaxZoom: 18,\n    ext: 'png'\n  });\n  \n  const Esri_WorldImagery = L.tileLayer(\n  'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', \n  {\n\t  attribution: esri,\n\t  minZoom: 0,\n  \tmaxZoom: 18,\n    ext: 'png'\n  }).addTo(map);\n  \n  // button to toggle basemap layer selection\n  L.control.layers(\n    {\n      \"Stamen Terrain\": Stamen_Terrain,\n      \"Stamen TonerLite\": Stamen_TonerLite,\n      \"Esri World Imagery\": Esri_WorldImagery\n    },\n    null,\n    {position: 'topleft'}\n  ).addTo(map);\n  \n  L.control.scale().addTo(map);\n  \n  map.setView([19.5438, -96.9102], 5);\n\n  return map; \n\n};\n\n```\n\n```{ojs}\n//| panel: sidebar\n\nviewof year =  Inputs.range(\n  [1990, 2019], \n  {value: 2019, step: 1, label: \"Año\"}\n)\nviewof k =  Inputs.range(\n  [20, 100], \n  {value: 50, step: 1, label: \"Radio max\"}\n)\nmeta = FileAttachment(\"data/worldbank_meta.csv\").csv()\nviewof indicator = Inputs.select(\n  new Map(meta.map((d) => [d.indicator, d.shortcode])),\n  { label: \"Indicador\" }\n)\nprojections = [\"Patterson\", \"NaturalEarth1\", \"Bertin1953\", \"InterruptedSinusoidal\", \"Armadillo\", \"Baker\", \"Gingery\", \"Berghaus\", \"Loximuthal\", \"Healpix\", \"InterruptedMollweideHemispheres\", \"Miller\", \"Aitoff\", \"ConicEqualArea\", \"Eckert3\", \"Hill\"]\nviewof proj = Inputs.select(projections, {label: \"Proyección\", width: 350})\nviewof color1 = Inputs.color({label: \"color\", value: \"#4682b4\"})\nviewof simpl =  Inputs.range( [0.01, 0.5], {value: 0.1, step: 0.01, label: \"Simplificación\"} )\nviewof x =  Inputs.range( [-180, 180], {value: 0, step: 1, label: \"Rotation (x)\"} )\nviewof y =  Inputs.range( [-90, 90], {value: 0, step: 1, label: \"Rotation (y)\"} )\n```\n\n```{ojs}\n//| echo: false\n\nbertin.draw({\nparams: {projection: proj + `.rotate([${x}, ${y}])`, clip: true }, \nlayers:[\n  { type : \"header\", text: title},\n  {type: \"bubble\", geojson: data, values: indicator, \n  fill: color1, fixmax: varmax, k, \n  tooltip: [\"$name\",d => d.properties[indicator]]},\n  {geojson: world2, fill: \"#CCC\"},\n  {type: \"graticule\"},  \n  {type: \"outline\"}\n]})\n```\n\n```{ojs}\nInputs.table(statsyear, {  columns: [\n    \"country\",\n    \"capital_city\",\n    \"region\",\n    indicator\n  ]})\n```\n\n```{ojs}\n//| echo: false\n\nviewof topnb = Inputs.range([5, 30], {label: \"Número de países a mostrar\", step: 1})\ntop = statsyear.sort((a, b) => d3.descending(+a[indicator], +b[indicator]))\n  .slice(0, topnb)\nPlot.plot({\n    marginLeft: 60,\n      grid: true,\n  x: {\n    //type: \"log\",\n    label: \"Años →\"\n  },\n  y: {\n    label: \"↑ Población\",\n    //type: \"log\",\n  },\n  marks: [\n    Plot.barY(top, {\n      x: \"iso3c\",\n      y: indicator,\n      sort: { x: \"y\", reverse: true },\n      fill: color1\n    }),\n    Plot.ruleY([0])\n  ]\n})\n```\n\n```{ojs}\n//| echo: false\n\nworld = FileAttachment(\"data/world.json\").json()\nstats = FileAttachment(\"data/worldbank_data.csv\").csv()\ngeo = require(\"./lib/geotoolbox.js\")\nworld2 = geo.simplify(world, {k: simpl})\nbertin = require(\"./lib/bertin.js\")\nstatsyear = stats.filter(d => d.date == year)\ndata = bertin.merge(world2, \"id\", statsyear, \"iso3c\")\nvarmax = d3.max(stats.filter(d => d.date == 2019), d => +d[indicator])\ntitle = meta.map((d) => [d.indicator, d.shortcode]).find((d) => d[1] == indicator)[0] + \" in \" + year\n```\n\n\n::::::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}